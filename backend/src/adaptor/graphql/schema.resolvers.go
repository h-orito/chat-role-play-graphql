package graphql

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.31

import (
	"chat-role-play/src/domain/model"
	graph1 "chat-role-play/src/middleware/graph"
	"chat-role-play/src/middleware/graph/gqlmodel"
	"chat-role-play/src/util/array"
	"context"
	"encoding/base64"
	"fmt"
	"strconv"
	"strings"
)

// Participants is the resolver for the participants field.
func (r *gameResolver) Participants(ctx context.Context, obj *gqlmodel.Game, paging *gqlmodel.PageableQuery) ([]*gqlmodel.Participant, error) {
	gameId, err := idToIntId(obj.ID)
	if err != nil {
		return nil, err
	}
	var pageSize, pageNumber *int
	if paging != nil {
		pageSize = &paging.PageSize
		pageNumber = &paging.PageNumber
	}
	pts, err := r.gameUsecase.FindGameParticipantsByGameID(gameId, pageSize, pageNumber)
	if err != nil {
		return nil, err
	}
	return array.Map(pts.List, func(p model.GameParticipant) *gqlmodel.Participant {
		return gqlmodel.MapToParticipant(p)
	}), nil

	// 以下はdataloaderで取得する実装
	// thunk := r.loaders.ParticipantLoader.Load(ctx, dataloader.StringKey(obj.ID))
	// data, err := thunk()
	// if err != nil {
	// 	return nil, err
	// }
	// pts := data.(*[]model.GameParticipant)
	// if pts == nil {
	// 	return nil, nil
	// }
	// return array.Map(*pts, func(p model.GameParticipant) *gqlmodel.Participant {
	// 	return gqlmodel.MapToParticipant(p)
	// }), nil
}

// CreateGame is the resolver for the createGame field.
func (r *mutationResolver) CreateGame(ctx context.Context, input gqlmodel.NewGame) (*gqlmodel.CreateGamePayload, error) {
	panic(fmt.Errorf("not implemented: CreateGame - createGame"))
}

// CreatePlayer is the resolver for the createPlayer field.
func (r *mutationResolver) CreatePlayer(ctx context.Context, input gqlmodel.NewPlayer) (*gqlmodel.CreatePlayerPayload, error) {
	panic(fmt.Errorf("not implemented: CreatePlayer - createPlayer"))
}

// CreateParticipant is the resolver for the createParticipant field.
func (r *mutationResolver) CreateParticipant(ctx context.Context, input gqlmodel.NewParticipant) (*gqlmodel.CreateParticipantPayload, error) {
	panic(fmt.Errorf("not implemented: CreateParticipant - createParticipant"))
}

// Games is the resolver for the games field.
func (r *queryResolver) Games(ctx context.Context, query gqlmodel.GamesQuery) ([]*gqlmodel.SimpleGame, error) {
	var intids *[]uint32
	if query.Ids != nil {
		ids := array.Map(query.Ids, func(id string) uint32 {
			intid, err := idToIntId(id)
			if err != nil {
				return 0
			}
			return intid
		})
		intids = &ids
	}
	var paging *model.PagingQuery
	if query.Paging != nil {
		paging = &model.PagingQuery{
			PageSize:   query.Paging.PageSize,
			PageNumber: query.Paging.PageNumber,
		}
	}
	q := model.GameQuery{
		IDs:    intids,
		Name:   query.Name,
		Paging: paging,
	}
	games, err := r.gameUsecase.Search(q)
	if err != nil {
		return nil, err
	}
	return array.Map(games, func(g model.Game) *gqlmodel.SimpleGame {
		return gqlmodel.MapToSimpleGame(&g)
	}), nil
}

// Game is the resolver for the game field.
func (r *queryResolver) Game(ctx context.Context, id string) (*gqlmodel.Game, error) {
	intid, err := idToIntId(id)
	if err != nil {
		return nil, err
	}
	g, err := r.gameUsecase.Find(intid)
	if err != nil {
		return nil, err
	}
	return gqlmodel.MapToGame(g), nil
}

// Players is the resolver for the players field.
func (r *queryResolver) Players(ctx context.Context) ([]*gqlmodel.Player, error) {
	panic(fmt.Errorf("not implemented: Players - players"))
}

// Player is the resolver for the player field.
func (r *queryResolver) Player(ctx context.Context, name string) (*gqlmodel.Player, error) {
	p, err := r.playerUsecase.FindByName(name)
	if err != nil {
		return nil, err
	}
	return gqlmodel.MapToPlayer(p), nil
}

// Game returns graph1.GameResolver implementation.
func (r *Resolver) Game() graph1.GameResolver { return &gameResolver{r} }

// Mutation returns graph1.MutationResolver implementation.
func (r *Resolver) Mutation() graph1.MutationResolver { return &mutationResolver{r} }

// Query returns graph1.QueryResolver implementation.
func (r *Resolver) Query() graph1.QueryResolver { return &queryResolver{r} }

type gameResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//   - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//     it when you're done.
//   - You have helper methods in this file. Move them out to keep these resolver files clean.
func idToIntId(id string) (uint32, error) {
	byte, err := base64.StdEncoding.DecodeString(id)
	if err != nil {
		return 0, err
	}
	parts := strings.Split(string(byte), ":")
	if len(parts) == 2 {
		number, err := strconv.Atoi(parts[1])
		if err != nil {
			return 0, err
		}
		return uint32(number), nil
	} else {
		return 0, fmt.Errorf("Invalid input format")
	}
}
