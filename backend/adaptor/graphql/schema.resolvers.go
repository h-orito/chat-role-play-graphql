package graphql

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.31

import (
	"chat-role-play/adaptor/auth"
	"chat-role-play/domain/model"
	graph1 "chat-role-play/middleware/graph"
	"chat-role-play/middleware/graph/gqlmodel"
	"chat-role-play/util/array"
	"context"
	"fmt"
)

// Participants is the resolver for the participants field.
func (r *gameResolver) Participants(ctx context.Context, obj *gqlmodel.Game, paging *gqlmodel.PageableQuery) ([]*gqlmodel.GameParticipant, error) {
	gameId, err := r.idToIntId(obj.ID)
	if err != nil {
		return nil, err
	}
	var pageSize, pageNumber *int
	if paging != nil {
		pageSize = &paging.PageSize
		pageNumber = &paging.PageNumber
	}
	pts, err := r.gameUsecase.FindGameParticipantsByGameID(gameId, pageSize, pageNumber)
	if err != nil {
		return nil, err
	}
	return array.Map(pts.List, func(p model.GameParticipant) *gqlmodel.GameParticipant {
		return gqlmodel.MapToParticipant(p)
	}), nil

	// 以下はdataloaderで取得する実装
	// thunk := r.loaders.ParticipantLoader.Load(ctx, dataloader.StringKey(obj.ID))
	// data, err := thunk()
	// if err != nil {
	// 	return nil, err
	// }
	// pts := data.(*[]model.GameParticipant)
	// if pts == nil {
	// 	return nil, nil
	// }
	// return array.Map(*pts, func(p model.GameParticipant) *gqlmodel.Participant {
	// 	return gqlmodel.MapToParticipant(p)
	// }), nil
}

// RegisterGame is the resolver for the registerGame field.
func (r *mutationResolver) RegisterGame(ctx context.Context, input gqlmodel.NewGame) (*gqlmodel.RegisterGamePayload, error) {
	user := auth.GetUser(ctx)
	if user == nil {
		return nil, fmt.Errorf("not authenticated")
	}
	game, err := r.gameUsecase.Register(input.MapToGame())
	if err != nil {
		return nil, err
	}
	return &gqlmodel.RegisterGamePayload{
		Game: gqlmodel.MapToGame(game),
	}, nil
}

// RegisterParticipant is the resolver for the registerParticipant field.
func (r *mutationResolver) RegisterParticipant(ctx context.Context, input gqlmodel.NewParticipant) (*gqlmodel.RegisterParticipantPayload, error) {
	panic(fmt.Errorf("not implemented: RegisterParticipant - registerParticipant"))
}

// Games is the resolver for the games field.
func (r *queryResolver) Games(ctx context.Context, query gqlmodel.GamesQuery) ([]*gqlmodel.SimpleGame, error) {
	var intids *[]uint32
	if query.Ids != nil {
		ids := array.Map(query.Ids, func(id string) uint32 {
			intid, err := r.idToIntId(id)
			if err != nil {
				return 0
			}
			return intid
		})
		intids = &ids
	}
	var paging *model.PagingQuery
	if query.Paging != nil {
		paging = &model.PagingQuery{
			PageSize:   query.Paging.PageSize,
			PageNumber: query.Paging.PageNumber,
		}
	}
	q := model.GameQuery{
		IDs:    intids,
		Name:   query.Name,
		Paging: paging,
	}
	games, err := r.gameUsecase.Search(q)
	if err != nil {
		return nil, err
	}
	return array.Map(games, func(g model.Game) *gqlmodel.SimpleGame {
		return gqlmodel.MapToSimpleGame(&g)
	}), nil
}

// Game is the resolver for the game field.
func (r *queryResolver) Game(ctx context.Context, id string) (*gqlmodel.Game, error) {
	intid, err := r.idToIntId(id)
	if err != nil {
		return nil, err
	}
	g, err := r.gameUsecase.Find(intid)
	if err != nil {
		return nil, err
	}
	return gqlmodel.MapToGame(g), nil
}

// GameParticipantGroups is the resolver for the gameParticipantGroups field.
func (r *queryResolver) GameParticipantGroups(ctx context.Context, gameID string) ([]*gqlmodel.GameParticipantGroup, error) {
	panic(fmt.Errorf("not implemented: GameParticipantGroups - gameParticipantGroups"))
}

// Player is the resolver for the player field.
func (r *queryResolver) Player(ctx context.Context, name string) (*gqlmodel.Player, error) {
	p, err := r.playerUsecase.FindByName(name)
	if err != nil {
		return nil, err
	}
	return gqlmodel.MapToPlayer(p), nil
}

// Charachips is the resolver for the charachips field.
func (r *queryResolver) Charachips(ctx context.Context, query gqlmodel.CharachipsQuery) ([]*gqlmodel.Charachip, error) {
	panic(fmt.Errorf("not implemented: Charachips - charachips"))
}

// Charachip is the resolver for the charachip field.
func (r *queryResolver) Charachip(ctx context.Context, id string) (*gqlmodel.Charachip, error) {
	panic(fmt.Errorf("not implemented: Charachip - charachip"))
}

// Chara is the resolver for the chara field.
func (r *queryResolver) Chara(ctx context.Context, id string) (*gqlmodel.Chara, error) {
	panic(fmt.Errorf("not implemented: Chara - chara"))
}

// Messages is the resolver for the messages field.
func (r *queryResolver) Messages(ctx context.Context, gameID string, query gqlmodel.MessageQuery) (*gqlmodel.Messages, error) {
	panic(fmt.Errorf("not implemented: Messages - messages"))
}

// Message is the resolver for the message field.
func (r *queryResolver) Message(ctx context.Context, id string) (*gqlmodel.Message, error) {
	panic(fmt.Errorf("not implemented: Message - message"))
}

// DirectMessages is the resolver for the directMessages field.
func (r *queryResolver) DirectMessages(ctx context.Context, gameID string, query gqlmodel.DirectMessageQuery) (*gqlmodel.DirectMessages, error) {
	panic(fmt.Errorf("not implemented: DirectMessages - directMessages"))
}

// Game returns graph1.GameResolver implementation.
func (r *Resolver) Game() graph1.GameResolver { return &gameResolver{r} }

// Mutation returns graph1.MutationResolver implementation.
func (r *Resolver) Mutation() graph1.MutationResolver { return &mutationResolver{r} }

// Query returns graph1.QueryResolver implementation.
func (r *Resolver) Query() graph1.QueryResolver { return &queryResolver{r} }

type gameResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
